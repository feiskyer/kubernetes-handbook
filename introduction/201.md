# Kubernetes Mastery: Scaling and Upgrading

## Scaling Applications

Scaling your application up or down in Kubernetes is as easy as adjusting the number of replicas in your Deployment:

![scale](../.gitbook/assets/scale%20%282%29.png)

Containers that automatically scale up will join the service pool, and those that are scaled down will similarly be removed from the service pool with no manual intervention required.

```bash
$ kubectl scale --replicas=3 deployment/nginx-app
$ kubectl get deploy
NAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-app   3         3         3            3           10m
```

## Rolling Updates

Rolling updates allow for seamless application upgrades by replacing containers incrementally:

```text
kubectl rolling-update frontend-v1 frontend-v2 --image=image:v2
```

![update1](../.gitbook/assets/update1%20%282%29.png)

![update2](../.gitbook/assets/update2%20%282%29.png)

![update3](../.gitbook/assets/update3%20%281%29.png)

![update4](../.gitbook/assets/update4.png)

If an update fails or there is a configuration mistake, you can revert changes on-the-go during a rolling update:

```text
kubectl rolling-update frontend-v1 frontend-v2 --rollback
```

It’s important to note that `kubectl rolling-update` is specific to ReplicationController. For Deployments with an update strategy set to RollingUpdate (this is the default when specified in the spec), the application will be automatically updated in a rolling fashion:

```yaml
  spec:
    replicas: 3
    selector:
      matchLabels:
        run: nginx-app
    strategy:
      rollingUpdate:
        maxSurge: 1
        maxUnavailable: 1
      type: RollingUpdate
```

For updating applications, the `kubectl set` command can be used directly:

```bash
kubectl set image deployment/nginx-app nginx-app=nginx:1.9.1
```

You can monitor the rolling update process using the `rollout` command:

```bash
$ kubectl rollout status deployment/nginx-app
Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
Waiting for rollout to finish: 2 of 3 updated replicas are available...
Waiting for rollout to finish: 2 of 3 updated replicas are available...
Waiting for rollout to finish: 2 of 3 updated replicas are available...
Waiting for rollout to finish: 2 of 3 updated replicas are available...
Waiting for rollout to finish: 2 of 3 updated replicas are available...
deployment "nginx-app" successfully rolled out
```

Deployments also support rollback:

```bash
$ kubectl rollout history deployment/nginx-app
deployments "nginx-app"
REVISION    CHANGE-CAUSE
1        <none>
2        <none>

$ kubectl rollout undo deployment/nginx-app
deployment "nginx-app" rolled back
```

## Resource Constraints

Through the use of cgroups, Kubernetes offers container resource management, which allows setting limits on CPU and memory usage for each container. For instance, you can restrict the nginx container from the aforementioned deployment to use a maximum of 50% CPU and 128MB of memory:

```bash
$ kubectl set resources deployment nginx-app -c=nginx --limits=cpu=500m,memory=128Mi
deployment "nginx" resource requirements updated
```

This is equivalent to setting resource limits in each Pod:

```yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: nginx
  name: nginx
spec:
  containers:
    - image: nginx
      name: nginx
      resources:
        limits:
          cpu: "500m"
          memory: "128Mi"
```

## Health Checks

As a container orchestration tool designed for applications, Kubernetes needs to ensure that containers are truly running properly after being deployed. It provides two probes (Probe, supporting exec, tcpSocket, and httpGet) to detect the status of the containers:

* LivenessProbe: Determines if an application is in a healthy state. If not, the container will be terminated and recreated.
* ReadinessProbe: Determines if an application has started properly and is ready to service traffic. If it’s not ready, it will not receive traffic from Kubernetes Services.

For deployments that are already up and running, manifest updates with health checks can be added using `kubectl edit deployment/nginx-app`:

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  labels:
    app: nginx
  name: nginx-default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - image: nginx
        imagePullPolicy: Always
        name: http
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        resources:
          limits:
            cpu: "500m"
            memory: "128Mi"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 15
          timeoutSeconds: 1
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          timeoutSeconds: 1
```

---

Now, let's refine the given content into a format that's more fitting for a popular science magazine. Here's how the translation and adaptation might look in that context:

# Exploring the Power of Kubernetes: Flex Your Cloud Muscles

## Supercharge Your Software with Easy Expansion

Imagine a garden where plants grow or shrink at your command. That's what scaling in Kubernetes feels like! When your app is the plant, all you need to do is turn the dial for the number of replicas in your Deployment and watch it magically adjust:

![scale](../.gitbook/assets/scale%20%282%29.png)

This bit of wizardry means your app's capacity grows or contracts as needed—no potion required. Just one command sets your desired state:

```bash
$ kubectl scale --replicas=3 deployment/nginx-app
$ kubectl get deploy
```

Voilà! Your once tiny app is now flexing like a tech titan.

## Non-Stop Improvement with Rolling Updates

Gone are the days of down times and "Sorry, we're updating" signs. With rolling updates, your app gets a refresh, one piece at a time, without breaking a sweat (or your user's experience):

![update1](../.gitbook/assets/update1%20%282%29.png)
...
![update4](../.gitbook/assets/update4.png)

And if something's amiss, just roll it back. It's like a time machine for your deployments!

```text
kubectl rolling-update frontend-v1 frontend-v2 --image=image:v2
```

Easily glide into the future or rewind to the good ol' days—your choice, captain!

## Stay Healthy, Stay Happy: Kubernetes' Fitness Tracker for Apps

Kubernetes doesn't just launch your containers—it makes sure they're in tip-top shape! With probes that are kind of like a fitness tracker for your apps, it ensures everything is up and running clean:

* LivenessProbe: Keeps an eye on your app's health. Is it lagging? Time for a fresh start.
* ReadinessProbe: Checks if your app is all set to welcome users. No traffic until it’s at 100% performance.

These health checkups are just edits away to keep your apps in peak condition:

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
...
        livenessProbe:
          httpGet:
            path: /
            port: 80
...
        readinessProbe:
          httpGet:
            path: /
            port: 80
...
```

Stay fit and online—Kubernetes has your back.

By adopting a playful tone and vivid analogies, we've transformed an academic explanation into an engaging story that captures the essence of Kubernetes’ features in a way that's enticing to the broader audience.